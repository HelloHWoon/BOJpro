#include <iostream>
#include <vector>
using namespace std;

/*
입력: 숫자의 수 N, 집합 B에 넣을 초기값의 개수 M
출력: 규칙 만족이 가능하면 M과 넣어야 할 숫자. 불가능하면 -1

[설명]
집합 A와 집합 B, 그리고 1부터 N까지 N개의 숫자가 있다. (N >= 5)
집합 B에 M개의 수를 넣는다. 이때, 넣은 수는 서로 연속되어서는 안된다.
-> 작업 과정이나 최종 결과에서 연속되는 경우는 상관없다.
나머지 숫자는 집합 A에 속한다.
"작업"을 통해 최종적으로 집합 A에 하나의 숫자만 남기는 것이 가능한지 여부를 판단.

[작업 규칙]
집합 A와 집합 B는 연속된 세 숫자 x, y, z에 대해 다음 조건을 만족하는 경우 교환이 가능하다.
1 : 집합 A에 x, y가, 집합 B에 z가 존재하는 경우
2 : 집합 A에 y, z가, 집합 B에 x가 존재하는 경우

[찾아낸 정보]
작업이 지속될수록 집합 A는 원소 개수가 줄어들고, 집합 B는 점점 늘어난다.
이 과정에서 N이 홀수인 경우, 집합 B에 짝수를 넣게 되면 집합 A에서 숫자 N을 교환할 수 없게
된다. 따라서 집합 A에 하나만 남기는 목적을 달성할 수 없다.
반대로 N이 짝수인 경우에 집합 B에 홀수를 넣게 되면 같은 현상이 반복된다.
-> 따라서 N이 홀수인 경우에는 집합 B 초기값을 홀수로, 짝수인 경우에는 집합 B 초기값을 짝수로
설정한다.

그렇게 오름차순으로 집합 B 초기값을 결정하면, 집합 B에서 가장 큰 숫자를 제외한
다른 숫자는 집합 A에 연속된 숫자가 없으므로 교환이 불가능하다.
따라서 가장 큰 숫자를 교환하고, 그렇게 얻은 더 큰 숫자로 교환이 가능하면 계속 교환을 한다.
이렇게 얻은 더 큰 숫자로 교환이 불가능할 때 까지 교환을 하는 것이 1차적인 교환이라 하자.
1차 교환이 끝나면 처음으로 교환한 숫자가 집합 A에서 연속이 된다.
이 연속된 숫자가 집합 A의 양 끝중 하나에 존재하거나, 둘 다에 존재하면 최종적으로 교환이
끝났을 때 1개만 남기는 것이 가능하다.

ex) N=7, M=2인 상황에서 집합 B에 1, 3을 넣고 시작하면, 1차 교환이 끝난 후
집합 A에는 2, 3, 5가 남는다. 여기서 연속된 숫자 2와 3이 가장 왼쪽에 있으므로
2, 3, 5 -> 4, 5 -> 6 과정을 통해 하나만 남기는 것이 가능하다.
N=10, M=2인 상황에서 집합 B에 2, 8을 넣고 시작하면, 1차 교환이 끝난 후
집합 A에는 1, 2, 4, 7, 8이 있다. 여기서 연속된 숫자 1과 2, 7과 8이 둘 다
양 끝에 존재하므로 교환이 가능한 것이다.

N=7, M=3인 상황에서 집합 B에 1, 3, 5를 넣고 시작하면, 1차 교환이 끝난 후
집합 A에는 2, 4, 5, 7이 남는다. 여기서 연속된 숫자 4와 5가 양 끝 어디에도
존재하지 않으므로 교환이 이루어졌을 때 1개만 남기고 교환할 수 없는 것이다.

여기서 알 수 있는 것은 한 쪽 끝에 연속된 숫자가 오도록 설정하는 것이다.
따라서 N이 홀수인 경우에 1, 3을 집합 B 초기값으로 설정하고, 다른 숫자를 N-2부터 2씩
홀수로 채워나가면 첫 교환에서 3과 4, 5를 교환해서 집합 A에 2, 3을 끝에 오도록 설정할 수 있다.
N이 짝수인 경우에는 2를 초기값으로 설정하고 다른 숫자를 N-2부터 2씩 짝수로 설정하면
첫 교환에서 2와 3, 4를 교환해서 집합 A에 1, 2를 끝에 오도록 설정할 수 있다.

그렇게 위 조건을 만족하기 위한 조건은 다음과 같다.

[N이 홀수인 경우]
2 <= M <= (N-1)/2 인 경우에 다 가능하다

[N이 짝수인 경우]
1 <= M <= (N/2)-1인 경우에 다 가능하다 (1인 경우에도 가능)
*/

int main(){
    int N, M;

    cin >> N >> M;

    int count = 0;

    //N이 홀수
    if (N % 2) {
        if (M >= 2 && M <= (N - 1) / 2) {
            cout << M << endl;

            cout << 1 << " " << 3 << " ";

            count += 2;

            while (M - count) {
                cout << N - (2 * (M - count)) << " ";
                count++;
            }
            cout << endl;
        }
        else {
            cout << -1 << endl;
        }
    }
    //N이 짝수
    else {
        if (M >= 1 && M <= (N / 2) - 1) {
            cout << M << endl;

            cout << 2 << " ";

            count++;

            while (M - count) {
                cout << N - (2 * (M - count)) << " ";
                count++;
            }
            cout << endl;
        }
        else {
            cout << -1 << endl;
        }
    }
    
    return 0;
}
